Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:56  C:\Software\iCub\firmware\controllerBll\Support\utilities.asm  Page 1



1                          ;=============================================================
2                          ;=== FILE: fp568d.s
3                          ;===
4                          ;=== Copyright (c)1998 Metrowerks, Inc.  All rights reserved.
5                          ;=============================================================
6                          ; Recommended tab stop = 8.
7      
8                          ;===============================================================================
9                          ; SECTION: the floating point code
10                                   SECTION fp_engine
11                                                   OPT     CC
12                                                   GLOBAL  ARTf_unpack2z
13                                                   GLOBAL  ARTf_unpack2
14                                                   GLOBAL  ARTf_unpackA
15     
16                                                   include "Fp568d.h"
17                                         ;=============================================================
18                                         ;=== FILE: Fp568d.h
19                                         ;===
20                                         ;=== Copyright (c)1998 Metrowerks, Inc.  All rights reserved.
21                                         ;=============================================================
22                                         ; Recommended tab stop = 8.
23     
24                                                   XREF    FPE_state
25     
26        0001                             UseRep    EQU     1
27     
28     
29                                         ; xhi/xlo save the x operand (passed in a) in two-op functions, which
30                                         ;       is handy for NaN handling, etc.
31                                         ; yhi/ylo save the y operand (passed in b) in two-op functions, which
32                                         ;       is handy for NaN handling, etc.
33                                         ; rexp is the result exponent
34                                         ; rsign is the result sign (compute as xor during unpack)
35                                         ; yflip is 0 for add, 0x8000 for sub, to indicate a flip of y's sign
36                                         ; omr contains value of original OMR register on entry to routine
37        0000                             xhi       EQU     0
38        0001                             xlo       EQU     1
39        0002                             yhi       EQU     2
40        0003                             ylo       EQU     3
41        0004                             yflip     EQU     4
42        0005                             rsign     EQU     5
43        0006                             rexp      EQU     6
44        0007                             saved_omr EQU     7
45     
46        0008                             SIZE_TEMPS EQU    8
47     
48                                         ;offsets for the unpack routines.
49        0002                             xhi_unp   EQU     2
50        0003                             xlo_unp   EQU     3
51        0004                             yhi_unp   EQU     4
52        0005                             ylo_unp   EQU     5
53        0006                             yflip_unp EQU     6
54        0007                             rsign_unp EQU     7
55        0008                             rexp_unp  EQU     8
56     
57     
58        0040                             INVALID   EQU     $0040
59        0010                             OVERFLOW  EQU     $0010
60        0008                             UNDERFLOW EQU     $0008
61        0020                             DIVBYZERO EQU     $0020
62        0004                             INEXACT   EQU     $0004
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:56  Fp568d.h  Page 2



63     
64        0000                             TONEAREST EQU     0
65        0001                             TOWARDZERO EQU    1
66        0002                             UPWARD    EQU     2
67        0003                             DOWNWARD  EQU     3
68        0002                             BITDIRRND EQU     2
69                                         BITDOWNORCHOP
70        0001                                       EQU     1
71     
72                                         LFPState  MACRO
73   m                                               move    x:FPE_state,x0
74   m                                               ENDM
75     
76                                         SetInvalid MACRO
77   m                                               bfset   #INVALID,x:FPE_state
78   m                                               ENDM
79     
80                                         SetInexact MACRO
81   m                                               bfset   #INEXACT,x:FPE_state
82   m                                               ENDM
83     
84                                         SetOverflow
85                                                   MACRO
86   m                                               bfset   #(OVERFLOW+INEXACT),x:FPE_state
87   m                                               ENDM
88     
89                                         SetUnderflow
90                                                   MACRO
91   m                                               bfset   #(UNDERFLOW+INEXACT),x:FPE_state
92   m                                               ENDM
93     
94                                         SetDivByZero
95                                                   MACRO
96   m                                               bfset   #DIVBYZERO,x:FPE_state
97   m                                               ENDM
98     
99                                         StFPState MACRO
100  m                                               move    x0,x:FPE_state
101  m                                               ENDM
102    
103                                        NORMALIZE_OMR
104                                                  MACRO
105  m                                               move    OMR,x:(SP-saved_omr)              ; save original OMR state
106  m                                               bfset   #$0100,OMR                        ; set CC bit
107  m                                               bfclr   #$0030,OMR                        ; clear R and SA bits
108  m                                               ENDM
109    
110                                        RESTORE_OMR
111                                                  MACRO
112  m                                               move    x:(SP-saved_omr),OMR              ; restore original OMR state
113  m                                               ENDM
114    
115    
116    
117                                        ;===============================================================================
118                                        ; UTILITY: f_unpackA, f_unpack2, f_unpack2z
119                                        ; DESCRIPTION: Unpack 1 or 2 input floats.
120                                        ;       f_unpackA -- unpacks a
121                                        ;       f_unpack2 -- unpack 2 operands, eor-ing the signs
122                                        ;       f_unpack2z -- f_unpack2, with x0 <-- 0, for mul and div
123                                        ;
124                                        ; INPUT: x in a; y in b for 2-operand functions;
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:56  C:\Software\iCub\firmware\controllerBll\Support\utilities.asm  Page 3



125                                        ;       flags in x0 for f_unpackA and f_unpack2
126                                        ; OUTPUT:
127                                        ;       f_unpackA -- a = bits, x0 = flags, y1 = exp
128                                        ;       f_unpack2, f_unpack2z -- b = x bits, x:rexp = x exp, x:xhi/xlo = x,
129                                        ;                       a = y bits, y1 = y exp, r0 = xor signs, x:yhi/ylo = y
130                                        ;
131                                        ;               !_____!
132                                        ;               |         |
133                                        ;               !_____!
134                                        ;               |         |
135                                        ;               !_____!<-- SP at the begining of Caller Routine.
136                                        ;               |         |
137                                        ;               !_____!
138                                        ;               |rexp |
139                                        ;               !_____!
140                                        ;               |rsign|
141                                        ;               !_____!
142                                        ;               |yflip|
143                                        ;               !_____!
144                                        ;               | ylo |
145                                        ;               !_____!
146                                        ;               | yhi |
147                                        ;               !_____!
148                                        ;               | xlo |
149                                        ;               !_____!
150                                        ;               | xhi |
151                                        ;               !_____!<-- SP after f_unpack2z or f_unpack2
152                                        ;               |         |
153                                        ;               !_____!
154                                        ;               |         |
155                                        ;               !_____!<-- SP at f_unpack2z or f_unpack2
156                                        ;               |         |
157    
158                                        ARTf_unpack2z:
159       P:000000 C000    [2 -        2]            move              #<0,x0                  ; set up flags for normalization
160                                        ARTf_unpack2:
161       P:000001 97FC    [2 -        4]            move              b1,x:(sp-yhi_unp)       ; save y operand for later ref.
162       P:000002 D1CB    [6 -       10]            move              b0,x:(sp-ylo_unp)
                   FFFB
163       P:000004 8307    [2 -       12]            move              b1,y1                   ; y sign
164       P:000005 7EA3    [2 -       14]            eor     a1,y1
165       P:000006 8803    [2 -       16]            move              y1,r0                   ; save eor sign for all binary ops
166       P:000007 96FE    [2 -       18]            move              a1,x:(sp-xhi_unp)       ; save x operand for later ref.
167       P:000008 D0CB    [6 -       24]            move              a0,x:(sp-xlo_unp)
                   FFFD
168       P:00000A E9C8    [6 -       30]            jsr     ARTf_unpackA                      ; a = bits, y1 = exp, x0 = flags
                   0013
169       P:00000C 6C80    [2 -       32]            tfr     a,b                               ; save x bits
170       P:00000D 93F8    [2 -       34]            move              y1,x:(sp-rexp_unp)
171       P:00000E 7635    [2 -       36]            lsl     x0                                ; shift flags over two
172       P:00000F 7635    [2 -       38]            lsl     x0
173       P:000010 B4FC    [2 -       40]            move              x:(sp-yhi_unp),a        ; set up operand y
174       P:000011 F0CB    [6 -       46]            move              x:(sp-ylo_unp),a0
                   FFFB
175                                                                                            ; Fall through to f_unpackA...
176                                        ARTf_unpackA:
177       P:000013 C108    [2 -       48]            move              #<8,y0                  ; shift count
178       P:000014 8906    [2 -       50]            move              a1,r1                   ; save exp field
179       P:000015 8308    [2 -       52]            move              a0,y1                   ; low bits for right shift into a (from left)
180       P:000016 673C    [2 -       54]            asll    a1,y0,a                           ; a1 = xbbb bbbb 0000 0000, x = implicit
181       P:000017 7D7C    [2 -       56]            lsrac   y1,y0,a                           ; a1 = xbbb bbbb cccc cccc, a0 = dddd dddd 0000 0000
182       P:000018 8311    [2 -       58]            move              r1,y1                   ; restore exp in bits seee eeee ebbb bbbb
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:56  C:\Software\iCub\firmware\controllerBll\Support\utilities.asm  Page 4



183       P:000019 76B7    [2 -       60]            lsl     y1                                ; strip sign bit
184       P:00001A 75FF    [2 -       62]            lsrr    y1,y0,y1                          ; right-align biased exp
185       P:00001B A30D    [4 -       66]            beq     unpZerSub                         ; exit if 0 or subnormal
186       P:00001C 5FC0    [2 -       68]            cmp     #$0ff,y1                          ; look for max exp
                   00FF
187       P:00001E A305    [4 -       72]            beq     unpNanInf
188       P:00001F 83C6    [4 -       76]            bfset   #$8000,a1                         ; jam the implicit 1-bit
                   8000
189       P:000021 87CA    [4 -       80]            move              #0,a2                   ; be sure high bits are Czero
                   0000
190       P:000023 EDD8    [10 -       90]           rts
191    
192                                        ; Distinguish Nan and Inf by significand, sans implicit bit
193                                        unpNanInf:
194       P:000024 4602    [2 -       92]            add     #<2,x0                            ; 2 for inf, 3 for NaN
195       P:000025 7430    [2 -       94]            asl     a                                 ; strip implicit bit
196       P:000026 A301    [4 -       98]            beq     unpSpecDone
197                                        unpBump:
198       P:000027 4601    [2 -      100]            add     #<1,x0
199                                        unpSpecDone:
200       P:000028 EDD8    [10 -      110]           rts
201    
202                                        ; Distinguish zero and subnormal by sig, with implicit = 0.
203                                        unpZerSub:
204                                                                                            ;tst    a               BUGGY INSTRUCTION TESTS HIGH HALF ONLY
205       P:000029 8E06    [2 -      112]            tstw    a1
206       P:00002A A202    [4 -      116]            bne     unpNorm
207       P:00002B 8E08    [2 -      118]            tstw    a0
208       P:00002C A37A    [4 -      122]            beq     unpBump                           ; go bump x0 by 1 and exit
209                                        unpNorm:
210       P:00002D C301    [2 -      124]            move              #<1,y1                  ; adjust exponent for tiny value
211       P:00002E 8E00    [2 -      126]            tstw    x0                                ; negative if unnormal
212       P:00002F A578    [4 -      130]            blt     unpSpecDone
213                                        unpNormLoop:
214       P:000030 5781    [2 -      132]            sub     #<1,y1                            ; dec exp
215       P:000031 7430    [2 -      134]            asl     a                                 ; sets N and V, so CCR messed up
216       P:000032 8E06    [2 -      136]            tstw    a1                                ; check N bit
217       P:000033 A47C    [4 -      140]            bge     unpNormLoop                       ; >= because only bits might be lowC
218                                                                                            ; guaranteed a2 = 0 here
219       P:000034 EDD8    [10 -      150]           rts
220    
221                                                  ENDSEC

0    Errors
0    Warnings


