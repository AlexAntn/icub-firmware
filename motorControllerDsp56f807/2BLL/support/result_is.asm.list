Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:56  C:\Software\iCub\firmware\controllerBll\Support\result_is.asm  Page 1



1                          ;=============================================================
2                          ;=== FILE: result_is.asm
3                          ;===
4                          ;=== Copyright (c)1998 Metrowerks, Inc.  All rights reserved.
5                          ;=============================================================
6                          ; Recommended tab stop = 8.
7      
8                          ;===============================================================================
9                          ; SECTION: the floating point code
10                                   SECTION fp_engine
11                                                   OPT     CC
12                                                   GLOBAL  ARTf_result_is_zero
13                                                   GLOBAL  ARTf_result_is_INF
14                                                   GLOBAL  ARTf_y_is_NaN
15                                                   GLOBAL  ARTf_result_is_Invalid
16                                                   GLOBAL  ARTf_x_and_y_are_NaN
17                                                   GLOBAL  ARTf_x_is_NaN
18     
19                                                   include "Fp568d.h"
20                                         ;=============================================================
21                                         ;=== FILE: Fp568d.h
22                                         ;===
23                                         ;=== Copyright (c)1998 Metrowerks, Inc.  All rights reserved.
24                                         ;=============================================================
25                                         ; Recommended tab stop = 8.
26     
27                                                   XREF    FPE_state
28     
29        0001                             UseRep    EQU     1
30     
31     
32                                         ; xhi/xlo save the x operand (passed in a) in two-op functions, which
33                                         ;       is handy for NaN handling, etc.
34                                         ; yhi/ylo save the y operand (passed in b) in two-op functions, which
35                                         ;       is handy for NaN handling, etc.
36                                         ; rexp is the result exponent
37                                         ; rsign is the result sign (compute as xor during unpack)
38                                         ; yflip is 0 for add, 0x8000 for sub, to indicate a flip of y's sign
39                                         ; omr contains value of original OMR register on entry to routine
40        0000                             xhi       EQU     0
41        0001                             xlo       EQU     1
42        0002                             yhi       EQU     2
43        0003                             ylo       EQU     3
44        0004                             yflip     EQU     4
45        0005                             rsign     EQU     5
46        0006                             rexp      EQU     6
47        0007                             saved_omr EQU     7
48     
49        0008                             SIZE_TEMPS EQU    8
50     
51                                         ;offsets for the unpack routines.
52        0002                             xhi_unp   EQU     2
53        0003                             xlo_unp   EQU     3
54        0004                             yhi_unp   EQU     4
55        0005                             ylo_unp   EQU     5
56        0006                             yflip_unp EQU     6
57        0007                             rsign_unp EQU     7
58        0008                             rexp_unp  EQU     8
59     
60     
61        0040                             INVALID   EQU     $0040
62        0010                             OVERFLOW  EQU     $0010
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:56  Fp568d.h  Page 2



63        0008                             UNDERFLOW EQU     $0008
64        0020                             DIVBYZERO EQU     $0020
65        0004                             INEXACT   EQU     $0004
66     
67        0000                             TONEAREST EQU     0
68        0001                             TOWARDZERO EQU    1
69        0002                             UPWARD    EQU     2
70        0003                             DOWNWARD  EQU     3
71        0002                             BITDIRRND EQU     2
72                                         BITDOWNORCHOP
73        0001                                       EQU     1
74     
75                                         LFPState  MACRO
76   m                                               move    x:FPE_state,x0
77   m                                               ENDM
78     
79                                         SetInvalid MACRO
80   m                                               bfset   #INVALID,x:FPE_state
81   m                                               ENDM
82     
83                                         SetInexact MACRO
84   m                                               bfset   #INEXACT,x:FPE_state
85   m                                               ENDM
86     
87                                         SetOverflow
88                                                   MACRO
89   m                                               bfset   #(OVERFLOW+INEXACT),x:FPE_state
90   m                                               ENDM
91     
92                                         SetUnderflow
93                                                   MACRO
94   m                                               bfset   #(UNDERFLOW+INEXACT),x:FPE_state
95   m                                               ENDM
96     
97                                         SetDivByZero
98                                                   MACRO
99   m                                               bfset   #DIVBYZERO,x:FPE_state
100  m                                               ENDM
101    
102                                        StFPState MACRO
103  m                                               move    x0,x:FPE_state
104  m                                               ENDM
105    
106                                        NORMALIZE_OMR
107                                                  MACRO
108  m                                               move    OMR,x:(SP-saved_omr)              ; save original OMR state
109  m                                               bfset   #$0100,OMR                        ; set CC bit
110  m                                               bfclr   #$0030,OMR                        ; clear R and SA bits
111  m                                               ENDM
112    
113                                        RESTORE_OMR
114                                                  MACRO
115  m                                               move    x:(SP-saved_omr),OMR              ; restore original OMR state
116  m                                               ENDM
117    
118    
119    
120    
121    
122    
123                                        ;===============================================================================
124                                        ; TERMINAL: f_result_is_zero
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:56  C:\Software\iCub\firmware\controllerBll\Support\result_is.asm  Page 3



125                                        ; DESCRIPTION: a gets 0 with sign from rsign
126                                        ; OUTPUT: a
127                                        ;
128                                        ARTf_result_is_zero:
129       P:000000 B4FB    [2 -        2]            move              x:(sp-rsign),a
130       P:000001 81C6    [4 -        6]            bfclr   #$7fff,a1
                   7FFF
131                                                  RESTORE_OMR
133       P:000005 9EF8    [2 -       14]            lea     (SP-SIZE_TEMPS)                   ; pop temp stack space
134       P:000006 EDD8    [10 -       24]           rts
135    
136    
137                                        ;===============================================================================
138                                        ; TERMINAL: f_result_is_INF
139                                        ; DESCRIPTION: a gets INF with sign from rsign
140                                        ; OUTPUT: a
141                                        ;
142                                        ARTf_result_is_INF:
143       P:000007 B4FB    [2 -       26]            move              x:(sp-rsign),a
144       P:000008 87C6    [4 -       30]            move              #$ff00,a1
                   FF00
145       P:00000A 7C30    [2 -       32]            asr     a
146                                                  RESTORE_OMR
148       P:00000D 9EF8    [2 -       40]            lea     (SP-SIZE_TEMPS)                   ; pop temp stack space
149       P:00000E EDD8    [10 -       50]           rts
150    
151    
152                                        ;===============================================================================
153                                        ; TERMINAL: f_y_is_NaN
154                                        ; DESCRIPTION: Know y is a NaN and other operand isn't.  If y is signaling,
155                                        ;       quiet it and signal invalid.  Else just return it.
156                                        ; INPUT: y in memory
157                                        ; OPTIMIZATION: Use shared code.
158                                        ;
159                                        ARTf_y_is_NaN:
160       P:00000F B4FE    [2 -       52]            move              x:(sp-yhi),a
161       P:000010 F0CB    [6 -       58]            move              x:(sp-ylo),a0
                   FFFD
162       P:000012 A912    [4 -       62]            bra     f_NaNs_common
163    
164    
165                                        ;===============================================================================
166                                        ; TERMINAL: f_result_is_Invalid
167                                        ; DESCRIPTION: a gets +NaN
168                                        ; OUTPUT: a
169                                        ;
170                                        ARTf_result_is_Invalid:
171       P:000013 B4FB    [2 -       64]            move              x:(sp-rsign),a
172       P:000014 87C6    [4 -       68]            move              #$ff80,a1
                   FF80
173       P:000016 7C30    [2 -       70]            asr     a
174                                        f_inv_common:
175                                                  SetInvalid
177                                                  RESTORE_OMR
179       P:00001C 9EF8    [2 -       86]            lea     (SP-SIZE_TEMPS)                   ; pop temp stack space
180       P:00001D EDD8    [10 -       96]           rts
181    
182    
183                                        ;===============================================================================
184                                        ; TERMINAL: f_x_and_y_are_NaN
185                                        ; DESCRIPTION: Both are NaNs.  If x is signaling, go signal.  Ditto for y.
186                                        ;       Else return x with no signal.
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:56  C:\Software\iCub\firmware\controllerBll\Support\result_is.asm  Page 4



187                                        ; INPUT: x bits in b, y bits in a.
188                                        ; TRICK: Use fact that NaN bits are delivered without implicit bit,
189                                        ;       with the quiet bit in bit #31.  Q=1, S=0, so try for the
190                                        ;       signal.
191                                        ;
192                                        ARTf_x_and_y_are_NaN:
193       P:00001E 8E07    [2 -       98]            tstw    b1                                ; check x first
194       P:00001F A402    [4 -      102]            bge     ARTf_x_is_NaN                     ; it's signaling
195       P:000020 8E06    [2 -      104]            tstw    a1
196       P:000021 A46D    [4 -      108]            bge     ARTf_y_is_NaN                     ; use y if it's signaling
197                                                                                            ; ...else fall through to f_x_is_NaN
198    
199    
200                                        ;===============================================================================
201                                        ; TERMINAL: f_x_is_NaN
202                                        ; DESCRIPTION: Know x is a NaN and other operand isn't.  If x is signaling,
203                                        ;       return canonical NaN and signal invalid.  Else just return it.
204                                        ; INPUT: x saved in low mem registers.
205                                        ;
206                                        ARTf_x_is_NaN:
207                                                                                            ; x has bits seee eeee eSff ffff ffff ffff ffff ffff,
208                                                                                            ; where S is the signaling bit.  If bit is clear, set and signal.
209       P:000022 F41F    [2 -      110]            move              x:(sp-xhi),a
210       P:000023 F0CB    [6 -      116]            move              x:(sp-xlo),a0
                   FFFF
211                                        f_NaNs_common:
212       P:000025 8BC6    [8 -      124]            brclr   #$0040,a1,f_inv_common            ; quiet bit clear? if yes, signaling
                   4070
213                                                  RESTORE_OMR
215       P:000029 9EF8    [2 -      132]            lea     (SP-SIZE_TEMPS)                   ; pop temp stack space
216       P:00002A EDD8    [10 -      142]           rts
217    
218    
219    
220    
221    
222                                                  ENDSEC

0    Errors
0    Warnings


