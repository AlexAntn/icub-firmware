Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:55  C:\Software\iCub\firmware\controllerBll\Support\ARTADDF32U.asm  Page 1



1                          ;=============================================================
2                          ;=== FILE: ARTADDF32U.asm
3                          ;===
4                          ;=== Copyright (c)1998 Metrowerks, Inc.  All rights reserved.
5                          ;=============================================================
6                          ; Recommended tab stop = 8.
7      
8                          ;===============================================================================
9                          ; SECTION: the floating point code
10                                   SECTION fp_engine
11                                                   OPT     CC
12                                                   GLOBAL  ARTADDF32U
13                                                   GLOBAL  ARTSUBF32U
14     
15                                                   include "Fp568d.h"
16                                         ;=============================================================
17                                         ;=== FILE: Fp568d.h
18                                         ;===
19                                         ;=== Copyright (c)1998 Metrowerks, Inc.  All rights reserved.
20                                         ;=============================================================
21                                         ; Recommended tab stop = 8.
22     
23                                                   XREF    FPE_state
24     
25        0001                             UseRep    EQU     1
26     
27     
28                                         ; xhi/xlo save the x operand (passed in a) in two-op functions, which
29                                         ;       is handy for NaN handling, etc.
30                                         ; yhi/ylo save the y operand (passed in b) in two-op functions, which
31                                         ;       is handy for NaN handling, etc.
32                                         ; rexp is the result exponent
33                                         ; rsign is the result sign (compute as xor during unpack)
34                                         ; yflip is 0 for add, 0x8000 for sub, to indicate a flip of y's sign
35                                         ; omr contains value of original OMR register on entry to routine
36        0000                             xhi       EQU     0
37        0001                             xlo       EQU     1
38        0002                             yhi       EQU     2
39        0003                             ylo       EQU     3
40        0004                             yflip     EQU     4
41        0005                             rsign     EQU     5
42        0006                             rexp      EQU     6
43        0007                             saved_omr EQU     7
44     
45        0008                             SIZE_TEMPS EQU    8
46     
47                                         ;offsets for the unpack routines.
48        0002                             xhi_unp   EQU     2
49        0003                             xlo_unp   EQU     3
50        0004                             yhi_unp   EQU     4
51        0005                             ylo_unp   EQU     5
52        0006                             yflip_unp EQU     6
53        0007                             rsign_unp EQU     7
54        0008                             rexp_unp  EQU     8
55     
56     
57        0040                             INVALID   EQU     $0040
58        0010                             OVERFLOW  EQU     $0010
59        0008                             UNDERFLOW EQU     $0008
60        0020                             DIVBYZERO EQU     $0020
61        0004                             INEXACT   EQU     $0004
62     
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:55  Fp568d.h  Page 2



63        0000                             TONEAREST EQU     0
64        0001                             TOWARDZERO EQU    1
65        0002                             UPWARD    EQU     2
66        0003                             DOWNWARD  EQU     3
67        0002                             BITDIRRND EQU     2
68                                         BITDOWNORCHOP
69        0001                                       EQU     1
70     
71                                         LFPState  MACRO
72   m                                               move    x:FPE_state,x0
73   m                                               ENDM
74     
75                                         SetInvalid MACRO
76   m                                               bfset   #INVALID,x:FPE_state
77   m                                               ENDM
78     
79                                         SetInexact MACRO
80   m                                               bfset   #INEXACT,x:FPE_state
81   m                                               ENDM
82     
83                                         SetOverflow
84                                                   MACRO
85   m                                               bfset   #(OVERFLOW+INEXACT),x:FPE_state
86   m                                               ENDM
87     
88                                         SetUnderflow
89                                                   MACRO
90   m                                               bfset   #(UNDERFLOW+INEXACT),x:FPE_state
91   m                                               ENDM
92     
93                                         SetDivByZero
94                                                   MACRO
95   m                                               bfset   #DIVBYZERO,x:FPE_state
96   m                                               ENDM
97     
98                                         StFPState MACRO
99   m                                               move    x0,x:FPE_state
100  m                                               ENDM
101    
102                                        NORMALIZE_OMR
103                                                  MACRO
104  m                                               move    OMR,x:(SP-saved_omr)              ; save original OMR state
105  m                                               bfset   #$0100,OMR                        ; set CC bit
106  m                                               bfclr   #$0030,OMR                        ; clear R and SA bits
107  m                                               ENDM
108    
109                                        RESTORE_OMR
110                                                  MACRO
111  m                                               move    x:(SP-saved_omr),OMR              ; restore original OMR state
112  m                                               ENDM
113    
114    
115    
116                                        ;===============================================================================
117                                        ; TERMINAL: f_add_INF_to_INF
118                                        ; DESCRIPTION: INF +/- INF can be INF or NaN
119                                        ; INPUT: x, y, though only signs matter now.
120                                        ; OUTPUT: Returns INF, with sign, or NaN.
121                                        ;
122                                        f_add_INF_to_INF:
123                                                                                            ; If adding magnitude, just deliver x. Otherwise invalid.
124       P:000000 BEFB    [2 -        2]            tstw    x:(sp-rsign)                      ; has xor of signs
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:55  C:\Software\iCub\firmware\controllerBll\Support\ARTADDF32U.asm  Page 3



125       P:000001 E584    [4 -        6]            jlt     ARTf_result_is_Invalid
                   0000
126                                                                                            ; fall through to f_result_is_x...
127    
128    
129                                        ;===============================================================================
130                                        ; TERMINAL: f_result_is_x, f_result_is_y
131                                        ; DESCRIPTION: Return saved arg (even if y has been flipped in sub).
132                                        ; INPUT: x saved in xhi/xlo, y on stack.
133                                        ; OUTPUT: a
134                                        ;
135                                        f_result_is_x:
136       P:000003 F41F    [2 -        8]            move              x:(sp-xhi),a
137       P:000004 F0CB    [6 -       14]            move              x:(sp-xlo),a0
                   FFFF
138                                                  RESTORE_OMR
140       P:000008 9EF8    [2 -       22]            lea     (SP-SIZE_TEMPS)                   ; pop temp stack space
141       P:000009 EDD8    [10 -       32]           rts
142    
143                                        f_result_is_y:
144       P:00000A B4FE    [2 -       34]            move              x:(sp-yhi),a
145       P:00000B F0CB    [6 -       40]            move              x:(sp-ylo),a0
                   FFFD
146                                                  RESTORE_OMR
148       P:00000F 9EF8    [2 -       48]            lea     (SP-SIZE_TEMPS)                   ; pop temp stack space
149       P:000010 EDD8    [10 -       58]           rts
150    
151    
152                                        ;===============================================================================
153                                        ; FUNCTION: ARTSUBF32U
154                                        ; DESCRIPTION: Float subtract.
155                                        ;
156                                        ; INPUT: a = x, (sp-2/3) = y
157                                        ; OUTPUT: a = result = x - y
158                                        ;
159                                        ARTSUBF32U:
160       P:000011 B5FE    [2 -       60]            move              x:(sp-2),b              ; high 16 bits and sign extension
161       P:000012 F1CB    [6 -       66]            move              x:(sp-3),b0             ; low 16 bits
                   FFFD
162       P:000014 DE4B    [2 -       68]            lea     (SP+SIZE_TEMPS)                   ; reserve stack space for all temps
                   0008
163                                                  NORMALIZE_OMR
167       P:00001C 87C0    [4 -       86]            move              #$8000,x0               ; sign flipper
                   8000
168       P:00001E 8307    [2 -       88]            move              b1,y1                   ; high part of y
169       P:00001F 7EC3    [2 -       90]            eor     x0,y1                             ; flip y to look like add
170       P:000020 8703    [2 -       92]            move              y1,b1                   ; replace operand
171       P:000021 A928    [4 -       96]            bra     f_add_common
172    
173                                        ;===============================================================================
174                                        ; TERMINAL: f_flipped_y_is_NaN, f_x_and_flipped_y_are_NaN
175                                        ; DESCRIPTION: Adjust y, whose sign may have been flipped, and go to terminal.
176                                        ; INPUT: y on stack, yflip
177                                        ; OUTPUT: none
178                                        ;
179                                        f_flipped_y_is_NaN:
180       P:000022 B0FE    [2 -       98]            move              x:(sp-yhi),x0
181       P:000023 B1FC    [2 -      100]            move              x:(sp-yflip),y0
182       P:000024 7E51    [2 -      102]            eor     y0,x0
183       P:000025 90FE    [2 -      104]            move              x0,x:(sp-yhi)
184       P:000026 E984    [6 -      110]            jmp     ARTf_y_is_NaN
                   0000
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:55  C:\Software\iCub\firmware\controllerBll\Support\ARTADDF32U.asm  Page 4



185    
186                                        f_x_and_flipped_y_are_NaN:
187       P:000028 B0FE    [2 -      112]            move              x:(sp-yhi),x0
188       P:000029 B1FC    [2 -      114]            move              x:(sp-yflip),y0
189       P:00002A 7E51    [2 -      116]            eor     y0,x0
190       P:00002B 90FE    [2 -      118]            move              x0,x:(sp-yhi)
191       P:00002C E984    [6 -      124]            jmp     ARTf_x_and_y_are_NaN
                   0000
192    
193    
194                                        ;===============================================================================
195                                        ; TERMINAL: f_add_zero_to_zero
196                                        ; DESCRIPTION: If signs agree, answer is easy, else fall through to subtract
197                                        ;       magnitude.
198                                        ; INPUT:
199                                        ; OUTPUT: Returns 0.
200                                        ;
201                                        f_add_zero_to_zero:
202                                                                                            ; When result is zero, if signs disagree let the rounding mode
203                                                                                            ; decide the sign of the result.  The IEEE standard says use +0
204                                                                                            ; unless rounding to -INF, in which case use -0.
205       P:00002E BEFB    [2 -      126]            tstw    x:(sp-rsign)                      ; the xor of operand signs
206       P:00002F A453    [4 -      130]            bge     f_result_is_x
207                                                                                            ; Fall through to f_add_zero_difference.
208    
209    
210                                        ;===============================================================================
211                                        ; TERMINAL: f_add_zero_difference
212                                        ; DESCRIPTION: Deliver zero based on rounding mode. +0, except when round down.
213                                        ; INPUT:
214                                        ; OUTPUT: Returns 0.
215                                        ;
216                                        f_add_zero_difference:
217                                                                                            ; TRICK: DOWNWARD = 3, so can use brset...
218       P:000030 8EF4    [12 -      142]           brset   #DOWNWARD,x:FPE_state,f_add_neg_zero
                   0000
                   0305
219       P:000033 6C30    [2 -      144]            clr     a
220                                                  RESTORE_OMR
222       P:000036 9EF8    [2 -      152]            lea     (SP-SIZE_TEMPS)                   ; pop temp stack space
223       P:000037 EDD8    [10 -      162]           rts
224                                        f_add_neg_zero:
225       P:000038 87C4    [4 -      166]            move              #$8000,a
                   8000
226                                                  RESTORE_OMR
228       P:00003C 9EF8    [2 -      174]            lea     (SP-SIZE_TEMPS)                   ; pop temp stack space
229       P:00003D EDD8    [10 -      184]           rts
230    
231                                        ;===============================================================================
232                                        ; FUNCTION: ARTADDF32U
233                                        ; DESCRIPTION: Float add.
234                                        ;
235                                        ; INPUT: a = x, (sp-2/3) = y
236                                        ; OUTPUT: a = x + y
237                                        ;
238                                        ARTADDF32U:
239                                                                                            ; Add and subtract share common code.  Subtract is identical to add
240                                                                                            ; but with y's sign flipped.
241                                                                                            ; SUBTLETY: In subtraction, must track y's original sign in case it's
242                                                                                            ; a NaN and need to return y EXACTLY as it was.
243                                                                                            ; Use r30 to hold sign flip flag: 0 for add 0x80000000 for subtract.
244                                                                                            ; This allows subtract to look like add, but with its operand's sign
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:55  C:\Software\iCub\firmware\controllerBll\Support\ARTADDF32U.asm  Page 5



245                                                                                            ; flipped.  The reason sub(x,y) is not the same as add(x,-y) is that
246                                                                                            ; sub(number,NaN) needs to return the NaN with its ORIGINAL sign.
247                                                                                            ;
248                                                                                            ; Compute (-1)^x.sign * 2^x.exp-bias * 1.xxxx plus/minus
249                                                                                            ; (-1)^y.sign * 2^y.exp-bias * 1.yyyy --->
250                                                                                            ; result.sign           = sign of larger operand, though in case
251                                                                                            ;       of zero result from operands of different signs, the result
252                                                                                            ;       sign depends on the rounding mode: + for all except toward -INF
253                                                                                            ; result.exp (biased)   = larger of two exps, subject to normalization
254                                                                                            ; result.bits           = rounded sum or difference
255                                                                                            ;
256                                                                                            ; Many SPECIAL CASES apply:
257                                                                                            ; Subnorms need not be normalized -- just adjust their exp to 1 and be
258                                                                                            ;       sure not to artificially set the implicit bit to 1.
259                                                                                            ; Magnitude add is benign. The worst that can happen is a 1-bit carry-out,
260                                                                                            ;       and even when the operands are aligned there can be rounding from
261                                                                                            ;       the Round (1st) bit.
262                                                                                            ; Magnitude subtract when exps are equal can lead to massive cancellation,
263                                                                                            ;       but never a rounding error.
264                                                                                            ; Magnitude subtract when exps differ by one can lead to massive cancellation,
265                                                                                            ;       and possible rounding from Round bit.
266                                                                                            ; Magnitude subtract when exps differ by more than one never suffers
267                                                                                            ;       cancellation by more than 1 bit, and requires general rounding.
268                                                                                            ; Tiny results can arise from the sum or difference of subnormals, or
269                                                                                            ;       from the difference of normals.  Must be careful when realigning
270                                                                                            ;       after cancellation to be ready to back off to subnormal.  The results
271                                                                                            ;       are always exact (i.e. no bit can lie to the right of the LSB of
272                                                                                            ;       a subnormal.
273                                                                                            ; The benign nature of subnormals (tinies) in add/sub means some care must
274                                                                                            ;       be taken in packing the result back up to fudge the exponent
275                                                                                            ;       (compare mul/div, where tiny results can be trickier).  At the cost
276                                                                                            ;       of a few instructions, tiny results filter through the mul/div
277                                                                                            ;       common code.
278    
279       P:00003E B5FE    [2 -      186]            move              x:(sp-2),b              ; high 16 bits and sign extension
280       P:00003F F1CB    [6 -      192]            move              x:(sp-3),b0             ; low 16 bits
                   FFFD
281       P:000041 DE4B    [2 -      194]            lea     (SP+SIZE_TEMPS)                   ; reserve stack space for all temps
                   0008
282                                                  NORMALIZE_OMR
286       P:000049 C000    [2 -      210]            move              #0,x0                   ; sign flipper
287                                                                                            ; Fall through to add/sub common code.
288    
289                                        f_add_common:
290       P:00004A 90FC    [2 -      212]            move              x0,x:(sp-yflip)         ; save add/sub distinction
291       P:00004B 87C0    [4 -      216]            move              #$e000,x0               ; mark no normalization
                   E000
292       P:00004D E9C8    [6 -      222]            jsr     ARTf_unpack2
                   0000
293       P:00004F 98FB    [2 -      224]            move              r0,x:(sp-rsign)         ; this is the xor, not result
294       P:000050 81C0    [4 -      228]            bfclr   #$ff00,x0                         ; clear normalization bits
                   FF00
295       P:000052 E9C8    [6 -      234]            jsr     ARTdispatch_x0
                   0000
296                                                                                            ; TRICK: table must follow the dispatch jsr.
297    
298       P:000054 A917    [4 -      238]            bra     f_add_numbers                     ; x is a number, y is number
299       P:000055 A90E    [4 -      242]            bra     go_f_result_is_x                  ;       y is zero (y may be flipped)
300       P:000056 A90F    [4 -      246]            bra     go_f_result_is_y                  ;       y is INF
301       P:000057 A94A    [4 -      250]            bra     f_flipped_y_is_NaN                ;       y is NaN
302    
303       P:000058 A90D    [4 -      254]            bra     go_f_result_is_y                  ; x is zero, y is number
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:55  C:\Software\iCub\firmware\controllerBll\Support\ARTADDF32U.asm  Page 6



304       P:000059 A954    [4 -      258]            bra     f_add_zero_to_zero                ;       y is zero
305       P:00005A A90B    [4 -      262]            bra     go_f_result_is_y                  ;       y is INF
306       P:00005B A946    [4 -      266]            bra     f_flipped_y_is_NaN                ;       y is NaN
307    
308       P:00005C A907    [4 -      270]            bra     go_f_result_is_x                  ; x is INF, y is number
309       P:00005D A906    [4 -      274]            bra     go_f_result_is_x                  ;       y is zero
310       P:00005E A90B    [4 -      278]            bra     go_f_add_INF_to_INF               ;       y is INF
311       P:00005F A942    [4 -      282]            bra     f_flipped_y_is_NaN                ;       y is NaN
312    
313       P:000060 A907    [4 -      286]            bra     go_f_x_is_NaN                     ; x is NaN, y is number
314       P:000061 A906    [4 -      290]            bra     go_f_x_is_NaN                     ;       y is zero
315       P:000062 A905    [4 -      294]            bra     go_f_x_is_NaN                     ;       y is INF
316       P:000063 A944    [4 -      298]            bra     f_x_and_flipped_y_are_NaN         ;       y is NaN
317    
318                                        go_f_result_is_x:
319       P:000064 E984    [6 -      304]            jmp     f_result_is_x
                   0003
320                                        go_f_result_is_y:
321       P:000066 E984    [6 -      310]            jmp     f_result_is_y
                   000A
322                                        go_f_x_is_NaN:
323       P:000068 E984    [6 -      316]            jmp     ARTf_x_is_NaN
                   0000
324                                        go_f_add_INF_to_INF:
325       P:00006A E984    [6 -      322]            jmp     f_add_INF_to_INF
                   0000
326    
327                                        f_add_numbers:
328                                                                                            ; x + y, with y's sign reflecting operation add/sub.
329                                                                                            ; b = x bits
330                                                                                            ; a = y bits
331                                                                                            ; rexp = x.exp
332                                                                                            ; y1 = y.exp
333                                                                                            ; rsign = r0 = xor signs
334                                                                                            ; yflip = 0x8000 if sub, 0 if add (i.e. fix to get original y)
335                                                                                            ; Align operands so larger one is in b/rexp, with exp in rexp, sgn in rsign.
336                                                                                            ; Smaller operand is in (rexp-yexp) & fyb.
337                                                                                            ; SPECIAL CASES:
338                                                                                            ;       Exponents match:
339                                                                                            ;               Add magnitude: Easy case, at most 1 rounding bit.
340                                                                                            ;                       May not carry-out (if one operand subnormal).
341                                                                                            ;               Sub magnitude: Can have massive cancellation with exact,
342                                                                                            ;                       possibly zero result.  Can't over/underflow, but
343                                                                                            ;                       may require subnormalization.
344                                                                                            ;       Exponents differ by 1:
345                                                                                            ;               Add magnitude: nothing special
346                                                                                            ;               Sub magnitude: Only other cancellation case, but may
347                                                                                            ;                       be inexact only if there's no cancellation.
348                                                                                            ;       Exponents differ by 2-8: shift without losing stickies
349                                                                                            ;       Exponents differ by 9-15: shift by 8, then 1-7
350                                                                                            ;       Exponents differ by 16: shift by a word
351                                                                                            ;       Exponents differ by 17-24, shift by a word, then 1-8
352                                                                                            ;       Exponents differ by > 24: smaller operand goes to sticky.
353                                                                                            ; WARNING: rsign indicates whether to add or sub magnitude,
354                                                                                            ;       but result sign is that of larger operand, tentatively xhi
355                                                                                            ;
356                                                                                            ; First, put xor in yflip, and y's sign in rsign.
357       P:00006C 98FC    [2 -      324]            move              r0,x:(sp-yflip)
358       P:00006D B0FE    [2 -      326]            move              x:(sp-yhi),x0
359       P:00006E 90FB    [2 -      328]            move              x0,x:(sp-rsign)
360                                                                                            ; Start checking for various cases.
361       P:00006F 8003    [2 -      330]            move              y1,x0                   ; tentative larger exp
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:55  C:\Software\iCub\firmware\controllerBll\Support\ARTADDF32U.asm  Page 7



362       P:000070 B1FA    [2 -      332]            move              x:(sp-rexp),y0
363       P:000071 7451    [2 -      334]            sub     y0,x0                             ; y.exp - x.exp = +/- shift
364       P:000072 A223    [4 -      338]            bne     f_add_unaligned                   ; go shift in hard case
365    
366       P:000073 BEFC    [2 -      340]            tstw    x:(sp-yflip)                      ; add or sub?
367       P:000074 A508    [4 -      344]            blt     f_sub_aligned
368                                        f_add_aligned:
369                                                                                            ; Two normalized operands will cause Carry -- the typical case,
370                                                                                            ; in which rounding and overflow must be checked.  If one or
371                                                                                            ; the other is subnormal, the result may not Carry (though it
372                                                                                            ; may be normal), and it's ready to be packed.  In order to share
373                                                                                            ; code with more typical case, just go through whole coerce routine.
374                                                                                            ; Note that in cases of subtract magnitude or of no carry in add
375                                                                                            ; magnitude, there's no chance for overflow.
376       P:000075 6400    [2 -      346]            add     b,a                               ; add magnitudes
377       P:000076 8E0A    [2 -      348]            tstw    a2
378       P:000077 E384    [4 -      352]            jeq     ARTf_coerce
                   0000
379       P:000079 7C30    [2 -      354]            asr     a                                 ; reinstate high bit
380       P:00007A 4781    [2 -      356]            add     #1,y1                             ; bump exp
381       P:00007B E984    [6 -      362]            jmp     ARTf_coerce
                   0000
382                                        f_sub_aligned:
383                                                                                            ; Subtraction may lead to borrow, in which case must negate and flip
384                                                                                            ; result sign.  This is the only case of a sign flip.
385       P:00007D 7400    [2 -      364]            sub     b,a
386       P:00007E A005    [4 -      368]            bhs     f_sub_no_borrow                   ; C clear if cool subtract
387       P:00007F 6C10    [2 -      370]            neg     a
388       P:000080 B1FB    [2 -      372]            move              x:(sp-rsign),y0
389       P:000081 85C1    [4 -      376]            bfchg   #$8000,y0                         ; flip result
                   8000
390       P:000083 91FB    [2 -      378]            move              y0,x:(sp-rsign)
391                                        f_sub_no_borrow:
392                                                                                            ; TRICK: can't depend on Z flag from neg, so test halves and
393                                                                                            ; take the chance to speed up the case of massive normalization.
394       P:000084 8E06    [2 -      380]            tstw    a1                                ; high half clear
395       P:000085 E584    [4 -      384]            jlt     ARTf_coerce                       ; already normal
                   0000
396       P:000087 A208    [4 -      388]            bne     f_sub_renorm                      ; go shift up to 16
397       P:000088 8E08    [2 -      390]            tstw    a0                                ; low half clear
398       P:000089 E384    [4 -      394]            jeq     f_add_zero_difference
                   0030
399                                                                                            ; Fall through if high half is zero, but low isn't.
400                                                                                            ; Do a quick 16-bit shift.
401       P:00008B 8408    [2 -      396]            move              a0,a                    ; clears a0
402       P:00008C 5790    [2 -      398]            sub     #<16,y1                           ; adjust exponent
403       P:00008D 8E06    [2 -      400]            tstw    a1                                ; check for luck case
404       P:00008E E584    [4 -      404]            jlt     ARTf_coerce
                   0000
405                                                                                            ; Fall through to f_sub_renorm
406                                        f_sub_renorm:
407                                                                                            ; Have exact result which must be normalized.  Ideally, we'd shift
408                                                                                            ; only until the biased exponent reaches 1, but it's easier to
409                                                                                            ; just go through with it and let the tiny cases get shifted back.
410                                                                                            ; They're exact, in any case.
411                                        f_sub_renorm_cont:
412       P:000090 6493    [2 -      406]            decw    y1
413       P:000091 7430    [2 -      408]            asl     a
414       P:000092 8E06    [2 -      410]            tstw    a1
415       P:000093 A47C    [4 -      414]            bge     f_sub_renorm_cont
416       P:000094 E984    [6 -      420]            jmp     ARTf_coerce
                   0000
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:55  C:\Software\iCub\firmware\controllerBll\Support\ARTADDF32U.asm  Page 8



417    
418                                        f_add_unaligned:
419                                                                                            ; CC from sub x:exp,(y1 in x0) and then bne.
420                                                                                            ; If gt, we're OK: y1 has larger exp and x0 has pos diff.
421                                                                                            ; If negative, swap operands
422                                                                                            ; yflip = xor of signs
423                                                                                            ; y is in a, y1, rsign  (bits, exp, sign)
424                                                                                            ; x is in b, rexp, xhi
425                                                                                            ; xor of signs is in yflip
426                                                                                            ; set up larger exponent in rexp and difference in x0
427       P:000096 A60B    [4 -      424]            bgt     f_add_swap_done
428                                        f_add_swap:
429       P:000097 F11F    [2 -      426]            move              x:(sp-xhi),y0           ; get sign
430       P:000098 91FB    [2 -      428]            move              y0,x:(sp-rsign)
431       P:000099 8106    [2 -      430]            move              a1,y0                   ; swap the 2 words of bits
432       P:00009A 8607    [2 -      432]            move              b1,a1
433       P:00009B 8701    [2 -      434]            move              y0,b1
434    
435       P:00009C 8108    [2 -      436]            move              a0,y0
436       P:00009D 8089    [2 -      438]            move              b0,a0
437       P:00009E 8181    [2 -      440]            move              y0,b0
438    
439       P:00009F B3FA    [2 -      442]            move              x:(sp-rexp),y1          ; larger exponent
440       P:0000A0 6E11    [2 -      444]            not     x0                                ; -difference = shift count
441       P:0000A1 4601    [2 -      446]            add     #1,x0                             ; poor man's "negw x0"
442                                        f_add_swap_done:
443                                                                                            ; Shifting up to 8 bits is easy.
444       P:0000A2 5E01    [2 -      448]            cmp     #1,x0
445       P:0000A3 A608    [4 -      452]            bgt     f_add_2_plus
446    
447                                                                                            ; Case 1: shift b by 1 bit.  Add is nothing special,
448                                                                                            ; but sub may require serious renormalization.
449       P:0000A4 7CB0    [2 -      454]            asr     b
450       P:0000A5 BEFC    [2 -      456]            tstw    x:(sp-yflip)                      ; test xor
451       P:0000A6 A44E    [4 -      460]            bge     f_add_aligned
452                                        f_sub_1:
453                                                                                            ; Sub operands shifted by 1 bit.  Can't borrow, but may require
454                                                                                            ; significant renormalization.
455       P:0000A7 7400    [2 -      462]            sub     b,a
456       P:0000A8 8E06    [2 -      464]            tstw    a1                                ; still normalized
457       P:0000A9 E584    [4 -      468]            jlt     ARTf_coerce
                   0000
458       P:0000AB A964    [4 -      472]            bra     f_sub_renorm_cont
459    
460                                        f_add_2_plus:
461       P:0000AC 5E08    [2 -      474]            cmp     #8,x0
462       P:0000AD A608    [4 -      478]            bgt     f_add_9_plus
463    
464                                                                                            ; Case 2-8: shift b by x0 within itself without fear of bit loss.
465       P:0000AE 8807    [2 -      480]            move              b1,r0
466       P:0000AF 8109    [2 -      482]            move              b0,y0
467       P:0000B0 754F    [2 -      484]            lsrr    y0,x0,y0
468       P:0000B1 8181    [2 -      486]            move              y0,b0
469       P:0000B2 C700    [2 -      488]            move              #0,b1
470       P:0000B3 8110    [2 -      490]            move              r0,y0
471       P:0000B4 7DCC    [2 -      492]            lsrac   y0,x0,b
472       P:0000B5 A92A    [4 -      496]            bra     f_add_realigned
473    
474                                        f_add_9_plus:
475       P:0000B6 5E10    [2 -      498]            cmp     #16,x0
476       P:0000B7 A614    [4 -      502]            bgt     f_add_17_plus
477       P:0000B8 A30C    [4 -      506]            beq     f_add_16
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:55  C:\Software\iCub\firmware\controllerBll\Support\ARTADDF32U.asm  Page 9



478    
479                                                                                            ; Case 9-15: shift in one shot, watching for stickies.
480       P:0000B9 8807    [2 -      508]            move              b1,r0
481       P:0000BA 8109    [2 -      510]            move              b0,y0
482       P:0000BB 6CB0    [2 -      512]            clr     b
483       P:0000BC 7DCC    [2 -      514]            lsrac   y0,x0,b                           ; low bits / stickies
484       P:0000BD 8E09    [2 -      516]            tstw    b0                                ; any stickies?
485       P:0000BE A301    [4 -      520]            beq     f_a_9_1
486       P:0000BF 4481    [2 -      522]            add     #1,b                              ; bump high half, safely
487                                        f_a_9_1:
488       P:0000C0 8187    [2 -      524]            move              b1,b0
489       P:0000C1 C700    [2 -      526]            move              #0,b1
490       P:0000C2 8110    [2 -      528]            move              r0,y0
491       P:0000C3 7DCC    [2 -      530]            lsrac   y0,x0,b                           ; upper half, shifted and added
492       P:0000C4 A91B    [4 -      534]            bra     f_add_realigned
493    
494                                                                                            ; Case 16: shift by a word
495                                        f_add_16:
496       P:0000C5 8E09    [2 -      536]            tstw    b0
497       P:0000C6 A302    [4 -      540]            beq     f_a_16_1
498       P:0000C7 83C7    [4 -      544]            bfset   #1,b1
                   0001
499                                        f_a_16_1:
500       P:0000C9 8187    [2 -      546]            move              b1,b0
501       P:0000CA C700    [2 -      548]            move              #0,b1
502       P:0000CB A914    [4 -      552]            bra     f_add_realigned
503    
504                                        f_add_17_plus:
505       P:0000CC 5E18    [2 -      554]            cmp     #24,x0
506       P:0000CD A60F    [4 -      558]            bgt     f_add_25_plus
507    
508                                                                                            ; Case 17-24: shift by a word and then the remainder.
509       P:0000CE 8107    [2 -      560]            move              b1,y0
510       P:0000CF 8E09    [2 -      562]            tstw    b0                                ; any stickies
511       P:0000D0 A302    [4 -      566]            beq     f_add_17_1
512       P:0000D1 83C1    [4 -      570]            bfset   #1,y0                             ; force sticky
                   0001
513                                        f_add_17_1:
514       P:0000D3 5610    [2 -      572]            sub     #16,x0
515       P:0000D4 6CB0    [2 -      574]            clr     b
516       P:0000D5 7DCC    [2 -      576]            lsrac   y0,x0,b                           ; b1 = low bits, b0 = sticky
517       P:0000D6 8E09    [2 -      578]            tstw    b0
518       P:0000D7 A302    [4 -      582]            beq     f_add_17_3
519       P:0000D8 83C7    [4 -      586]            bfset   #1,b1
                   0001
520                                        f_add_17_3:
521       P:0000DA 8187    [2 -      588]            move              b1,b0
522       P:0000DB C700    [2 -      590]            move              #0,b1
523       P:0000DC A903    [4 -      594]            bra     f_add_realigned
524    
525                                                                                            ; Case of huge shift --> all sticky.
526                                        f_add_25_plus
527       P:0000DD 6CB0    [2 -      596]            clr     b
528       P:0000DE 87C9    [4 -      600]            move              #1,b0
                   0001
529                                                                                            ; Fall through to f_add_realigned
530    
531                                        f_add_realigned:
532                                                                                            ; Now add b to or subtract it from a.  At worst, there can be
533                                                                                            ; a carry-out on add, or a 1-bit renormalization on subtract.
534                                                                                            ; Always round and check for overflow, though overflow can't
535                                                                                            ; happen on a magnitude subtract.  At the bottom of the range,
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:55  C:\Software\iCub\firmware\controllerBll\Support\ARTADDF32U.asm  Page 10



536                                                                                            ; subtracting two numbers near the smallest normal can lead to
537                                                                                            ; a subnormal, but it will be exact.
538       P:0000E0 BEFC    [2 -      602]            tstw    x:(sp-yflip)                      ; add or sub?
539       P:0000E1 A408    [4 -      606]            bge     f_add_with_sticky
540                                        ;f_sub_easy:
541       P:0000E2 7400    [2 -      608]            sub     b,a                               ; can't borrow, might need 1-bit shift
542       P:0000E3 8E06    [2 -      610]            tstw    a1
543       P:0000E4 E584    [4 -      614]            jlt     ARTf_coerce
                   0000
544       P:0000E6 7430    [2 -      616]            asl     a
545       P:0000E7 5781    [2 -      618]            sub     #1,y1                             ; adjust exponent
546       P:0000E8 E984    [6 -      624]            jmp     ARTf_coerce
                   0000
547                                        f_add_with_sticky:
548                                                                                            ; Add operands shifted by bunch o' bits.  Watch for sticky bit.
549       P:0000EA 6400    [2 -      626]            add     b,a
550       P:0000EB 8E0A    [2 -      628]            tstw    a2                                ; carry out?
551       P:0000EC E384    [4 -      632]            jeq     ARTf_coerce
                   0000
552       P:0000EE 4781    [2 -      634]            add     #1,y1                             ; bump exponent for right shift
553       P:0000EF 7C30    [2 -      636]            asr     a
554       P:0000F0 E084    [4 -      640]            jhs     ARTf_coerce
                   0000
555       P:0000F2 83C8    [4 -      644]            bfset   #1,a0                             ; force sticky
                   0001
556       P:0000F4 E984    [6 -      650]            jmp     ARTf_coerce
                   0000
557    
558                                                  ENDSEC

0    Errors
0    Warnings


