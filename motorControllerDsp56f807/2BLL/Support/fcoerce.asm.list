Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:56  C:\Software\iCub\firmware\controllerBll\Support\fcoerce.asm  Page 1



1                          ;=============================================================
2                          ;=== FILE: fcoerce.asm
3                          ;===
4                          ;=== Copyright (c)1998 Metrowerks, Inc.  All rights reserved.
5                          ;=============================================================
6                          ; Recommended tab stop = 8.
7      
8                          ;===============================================================================
9                          ; SECTION: the floating point code
10                                   SECTION fp_engine
11                                                   OPT     CC
12                                                   GLOBAL  ARTf_coerce
13     
14                                                   include "Fp568d.h"
15                                         ;=============================================================
16                                         ;=== FILE: Fp568d.h
17                                         ;===
18                                         ;=== Copyright (c)1998 Metrowerks, Inc.  All rights reserved.
19                                         ;=============================================================
20                                         ; Recommended tab stop = 8.
21     
22                                                   XREF    FPE_state
23     
24        0001                             UseRep    EQU     1
25     
26     
27                                         ; xhi/xlo save the x operand (passed in a) in two-op functions, which
28                                         ;       is handy for NaN handling, etc.
29                                         ; yhi/ylo save the y operand (passed in b) in two-op functions, which
30                                         ;       is handy for NaN handling, etc.
31                                         ; rexp is the result exponent
32                                         ; rsign is the result sign (compute as xor during unpack)
33                                         ; yflip is 0 for add, 0x8000 for sub, to indicate a flip of y's sign
34                                         ; omr contains value of original OMR register on entry to routine
35        0000                             xhi       EQU     0
36        0001                             xlo       EQU     1
37        0002                             yhi       EQU     2
38        0003                             ylo       EQU     3
39        0004                             yflip     EQU     4
40        0005                             rsign     EQU     5
41        0006                             rexp      EQU     6
42        0007                             saved_omr EQU     7
43     
44        0008                             SIZE_TEMPS EQU    8
45     
46                                         ;offsets for the unpack routines.
47        0002                             xhi_unp   EQU     2
48        0003                             xlo_unp   EQU     3
49        0004                             yhi_unp   EQU     4
50        0005                             ylo_unp   EQU     5
51        0006                             yflip_unp EQU     6
52        0007                             rsign_unp EQU     7
53        0008                             rexp_unp  EQU     8
54     
55     
56        0040                             INVALID   EQU     $0040
57        0010                             OVERFLOW  EQU     $0010
58        0008                             UNDERFLOW EQU     $0008
59        0020                             DIVBYZERO EQU     $0020
60        0004                             INEXACT   EQU     $0004
61     
62        0000                             TONEAREST EQU     0
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:56  Fp568d.h  Page 2



63        0001                             TOWARDZERO EQU    1
64        0002                             UPWARD    EQU     2
65        0003                             DOWNWARD  EQU     3
66        0002                             BITDIRRND EQU     2
67                                         BITDOWNORCHOP
68        0001                                       EQU     1
69     
70                                         LFPState  MACRO
71   m                                               move    x:FPE_state,x0
72   m                                               ENDM
73     
74                                         SetInvalid MACRO
75   m                                               bfset   #INVALID,x:FPE_state
76   m                                               ENDM
77     
78                                         SetInexact MACRO
79   m                                               bfset   #INEXACT,x:FPE_state
80   m                                               ENDM
81     
82                                         SetOverflow
83                                                   MACRO
84   m                                               bfset   #(OVERFLOW+INEXACT),x:FPE_state
85   m                                               ENDM
86     
87                                         SetUnderflow
88                                                   MACRO
89   m                                               bfset   #(UNDERFLOW+INEXACT),x:FPE_state
90   m                                               ENDM
91     
92                                         SetDivByZero
93                                                   MACRO
94   m                                               bfset   #DIVBYZERO,x:FPE_state
95   m                                               ENDM
96     
97                                         StFPState MACRO
98   m                                               move    x0,x:FPE_state
99   m                                               ENDM
100    
101                                        NORMALIZE_OMR
102                                                  MACRO
103  m                                               move    OMR,x:(SP-saved_omr)              ; save original OMR state
104  m                                               bfset   #$0100,OMR                        ; set CC bit
105  m                                               bfclr   #$0030,OMR                        ; clear R and SA bits
106  m                                               ENDM
107    
108                                        RESTORE_OMR
109                                                  MACRO
110  m                                               move    x:(SP-saved_omr),OMR              ; restore original OMR state
111  m                                               ENDM
112    
113    
114    
115                                        ;===============================================================================
116                                        ; TERMINAL: f_coerce
117                                        ; DESCRIPTION: Coerce a value to float format.
118                                        ; INPUT: a = bits, y1 = exponent, x:(sp-rsign) = sign.
119                                        ; OUTPUT: a
120                                        ;
121                                        ARTf_coerce:
122       P:000000 8E03    [2 -        2]            tstw    y1
123       P:000001 E784    [4 -        6]            jle     f_tiny_result
                   0043
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:56  C:\Software\iCub\firmware\controllerBll\Support\fcoerce.asm  Page 3



124       P:000003 89C8    [4 -       10]            bftstl  #$0ff,a0                          ; C clear if any nonzero rounding bits
                   00FF
125       P:000005 A019    [4 -       14]            bcc     f_round
126                                        f_checkoflow:
127       P:000006 5FC0    [2 -       16]            cmp     #$0ff,y1                          ; huge exp?
                   00FF
128       P:000008 E484    [4 -       20]            jge     f_oflow
                   0060
129                                        f_pack:
130                                                                                            ; a = bits, y1 = exp, x:rsign has sign bit
131       P:00000A C008    [2 -       22]            move              #8,x0                   ; shift count
132       P:00000B 8806    [2 -       24]            move              a1,r0                   ; r0 = rrss
133       P:00000C 8108    [2 -       26]            move              a0,y0                   ; y0 = tt00
134       P:00000D 754C    [2 -       28]            lsrr    y0,x0,a                           ; a  = 00tt 0000
135       P:00000E 8086    [2 -       30]            move              a1,a0                   ; a  = 00tt 00tt
136       P:00000F 860A    [2 -       32]            move              a2,a1                   ; a  = 0000 00tt
137       P:000010 8110    [2 -       34]            move              r0,y0
138       P:000011 7D4C    [2 -       36]            lsrac   y0,x0,a                           ; a  = 00rr sstt
139                                                                                            ; Clear implicit, and if it's already zero, decrement the exp.
140       P:000012 81C6    [4 -       40]            bfclr   #$0080,a1                         ; knock off lead bit
                   0080
141       P:000014 A101    [4 -       44]            bcs     f_pack_norm                       ; C set when lead bit is 0
142       P:000015 6493    [2 -       46]            decw    y1                                ; decrement exp (to 0)
143                                        f_pack_norm:
144       P:000016 B5FB    [2 -       48]            move              x:(sp-rsign),b          ; b  = xxxx xyyyy... bits, where
145                                                                                            ; x is the sign bit
146       P:000017 67DF    [2 -       50]            lsll    y1,x0,y1                          ; align exp left
147       P:000018 8703    [2 -       52]            move              y1,b1                   ; b = xxxx eeee eeee 0000... bits
148       P:000019 7CB0    [2 -       54]            asr     b                                 ; b = xxxx xeee eeee e000... bits
149       P:00001A 6400    [2 -       56]            add     b,a                               ; add = or, when bits are exclusive
150                                                  RESTORE_OMR
152       P:00001D 9EF8    [2 -       64]            lea     (SP-SIZE_TEMPS)                   ; pop temp stack space
153       P:00001E EDD8    [10 -       74]           rts
154    
155                                        ;===============================================================================
156                                        ; TERMINAL: f_round
157                                        ; DESCRIPTION: Round an inexact value and continue with coercion.
158                                        ; INPUT: a = bits normalized to 0xffffff00
159                                        ;       y1 = biased, repaired exp
160                                        ;       rsign.15 = result sign
161                                        ; OUTPUT: rounded significand with junk low bits, Inexact set
162                                        ;
163                                        f_round:
164                                                  SetInexact
166                                        f_tiny_resume:
167                                                                                            ; Get back here with a tiny, inexact result.  Underflow and inexact
168                                                                                            ; have been signaled in that case.
169       P:000022 8EF4    [12 -       94]           brset   #BITDIRRND,x:FPE_state,f_round_dirrnd
                   0000
                   0215
170       P:000025 8EF4    [12 -      106]           brset   #BITDOWNORCHOP,x:FPE_state,f_checkoflow
                   0000
                   015E
171                                                                                            ; round to nearest...
172       P:000028 8BC8    [8 -      114]            brclr   #$0080,a0,f_checkoflow            ; done if round bit clear
                   805C
173       P:00002A 89C8    [4 -      118]            bftstl  #$007f,a0                         ; C clear if any set
                   007F
174       P:00002C A002    [4 -      122]            bcc     f_roundup
175                                                                                            ; get here in half-way case
176       P:00002D 8BC8    [8 -      130]            brclr   #$0100,a0,f_checkoflow            ; already even, so no round
                   01D7
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:56  C:\Software\iCub\firmware\controllerBll\Support\fcoerce.asm  Page 4



177                                        f_roundup:
178       P:00002F 87CA    [4 -      134]            move              #0,a2                   ; clear carry-out bits
                   0000
179       P:000031 6CB0    [2 -      136]            clr     b
180       P:000032 87C9    [4 -      140]            move              #$0100,b0               ; increment unit
                   0100
181       P:000034 6400    [2 -      142]            add     b,a
182       P:000035 8BCA    [8 -      150]            brclr   #1,a2,f_checkoflow                ; look for carry-out
                   014F
183       P:000037 7C30    [2 -      152]            asr     a                                 ; realign
184       P:000038 4781    [2 -      154]            add     #1,y1
185       P:000039 A94C    [4 -      158]            bra     f_checkoflow
186    
187                                        f_round_dirrnd:
188       P:00003A 8EF4    [12 -      170]           brset   #BITDOWNORCHOP,x:FPE_state,f_round_downward
                   0000
                   0103
189                                        ;f_round_upward:
190       P:00003D BEFB    [2 -      172]            tstw    x:(sp-rsign)
191       P:00003E A470    [4 -      176]            bge     f_roundup
192       P:00003F A946    [4 -      180]            bra     f_checkoflow
193                                        f_round_downward:
194       P:000040 BEFB    [2 -      182]            tstw    x:(sp-rsign)
195       P:000041 A56D    [4 -      186]            blt     f_roundup
196       P:000042 A943    [4 -      190]            bra     f_checkoflow
197    
198    
199                                        ;===============================================================================
200                                        ; TERMINAL: f_tiny_result
201                                        ; DESCRIPTION: Subnormalize a result and return to rounding...
202                                        ; INPUT: a = bits normalized to 0xffffff00, with rounding bits in 0x0...0ff
203                                        ;       y1 = biased, underflowed exp
204                                        ;       rsign = result sign
205                                        ; OUTPUT: subnormalized signif. and exp=1 to continue at f_tiny_resume if
206                                        ;       inexact and at f_pack if exact.  Note, it's OK to be tiny and exact;
207                                        ;       no underflow occurs.
208                                        f_tiny_result:
209                                                                                            ; 1 - exp = number of bits to shift right in order to achieve
210                                                                                            ; exp of 1 with unnormalized value.
211                                                                                            ; If shift > 24, then every bit is sticky.
212                                                                                            ; Else shift requisite amount.
213                                                                                            ; In any case, the exponent goes to the minimum, 1.
214       P:000043 C001    [2 -      192]            move              #1,x0
215       P:000044 7471    [2 -      194]            sub     y1,x0                             ; x0 = 1 - exp = # bits to shift
216       P:000045 5E19    [2 -      196]            cmp     #25,x0                            ; 25 < x0 means minuscule
217       P:000046 A611    [4 -      200]            bgt     f_very_tiny_result
218    
219                                                                                            ; Shift fr right by x0, with bits shifted off or-ed into sticky.
220       P:000047 C100    [2 -      202]            move              #0,y0                   ; accumulate stickies into b
221       P:000048 8301    [2 -      204]            move              y0,y1                   ; (don't need y1 for exp here)
222       P:000049 6CB0    [2 -      206]            clr     b
223       P:00004A CCC0    [6 -      212]            do      x0,sub_loop_end
                   004D
224       P:00004C 7C30    [2 -      214]            asr     a                                 ; C <-- sticky bit
225       P:00004D 6684    [2 -      216]            adc     y,b
226                                        sub_loop_end:
227                                                                                            ; b0 is at most 25, if all bits are one
228       P:00004E 8108    [2 -      218]            move              a0,y0
229       P:00004F 8309    [2 -      220]            move              b0,y1
230       P:000050 66D3    [2 -      222]            or      y0,y1
231       P:000051 8083    [2 -      224]            move              y1,a0
232       P:000052 C301    [2 -      226]            move              #1,y1                   ; set minimum exponent
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:56  C:\Software\iCub\firmware\controllerBll\Support\fcoerce.asm  Page 5



233                                                                                            ; CASES:
234                                                                                            ;       Exact --> no underflow or inexact; just stuff subnormal
235                                                                                            ;       Rounds up to min normal --> be sure biased exp is 1
236                                                                                            ;       Rounds to subnormal --> inexact and underflow
237       P:000053 89C8    [4 -      230]            bftstl  #$00ff,a0                         ; sets C if exact
                   00FF
238       P:000055 E184    [4 -      234]            jlo     f_pack
                   000A
239       P:000057 A904    [4 -      238]            bra     f_set_uflow
240    
241                                        f_very_tiny_result:
242                                                                                            ; Value underflows to 0 or tiny subnormal.  Latter arises
243                                                                                            ; depending on rounding.
244       P:000058 6C30    [2 -      240]            clr     a
245       P:000059 87C8    [4 -      244]            move              #1,a0                   ; barest sticky
                   0001
246       P:00005B 8308    [2 -      246]            move              a0,y1                   ; min exponent
247                                        f_set_uflow:
248                                                  SetUnderflow
250       P:00005F A942    [4 -      258]            bra     f_tiny_resume                     ; go round and pack result
251    
252    
253                                        ;===============================================================================
254                                        ; TERMINAL: f_oflow
255                                        ; DESCRIPTION: Stuff INF or largest result, according to rounding mode. Signal
256                                        ;       overflow and inexact.
257                                        ;
258                                        f_oflow:
259                                                                                            ; Know result is too big. Signal, and respond according to the rounding
260                                                                                            ; mode.
261                                                  SetOverflow
263                                                                                            ; CASES:
264                                                                                            ; nearest, pos & upward, neg & downward --> INF
265                                                                                            ; chop, pos & downward, neg & upward --> HUGE
266       P:000063 8EF4    [12 -      278]           brset   #BITDIRRND,x:FPE_state,f_oflow_dirrnd
                   0000
                   0205
267       P:000066 8EF4    [12 -      290]           brset   #BITDOWNORCHOP,x:FPE_state,f_result_is_huge
                   0000
                   010A
268                                        f_go_inf:
269       P:000069 E984    [6 -      296]            jmp     ARTf_result_is_INF
                   0000
270    
271    
272                                        ;===============================================================================
273                                        ; TERMINAL: f_oflow_dirrnd
274                                        ; DESCRIPTION: Check mode and sign to decide huge or INF.
275                                        ;
276                                        f_oflow_dirrnd:
277       P:00006B 8EF4    [12 -      308]           brset   #BITDOWNORCHOP,x:FPE_state,f_oflow_down
                   0000
                   0103
278       P:00006E BEFB    [2 -      310]            tstw    x:(sp-rsign)
279       P:00006F A479    [4 -      314]            bge     f_go_inf
280       P:000070 A902    [4 -      318]            bra     f_result_is_huge
281                                        f_oflow_down:
282       P:000071 BEFB    [2 -      320]            tstw    x:(sp-rsign)
283       P:000072 A576    [4 -      324]            blt     f_go_inf
284                                                                                            ; Fall through to huge...
285    
286    
Motorola DSP56800 Assembler  Version 6.3.16  110-11-03  12:48:56  C:\Software\iCub\firmware\controllerBll\Support\fcoerce.asm  Page 6



287                                        ;===============================================================================
288                                        ; TERMINAL: f_result_is_huge
289                                        ; DESCRIPTION: Stuff huge with sign from rsign.
290                                        ; Want the value 0x7f7fffff.  Get it by adding -1 to 0x7f800000.
291                                        ;
292                                        f_result_is_huge:
293       P:000073 B4FB    [2 -      326]            move              x:(sp-rsign),a
294       P:000074 87C6    [4 -      330]            move              #$feff,a1
                   FEFF
295       P:000076 87C8    [4 -      334]            move              #$ffff,a0
                   FFFF
296       P:000078 7C30    [2 -      336]            asr     a
297                                                  RESTORE_OMR
299       P:00007B 9EF8    [2 -      344]            lea     (SP-SIZE_TEMPS)                   ; pop temp stack space
300       P:00007C EDD8    [10 -      354]           rts
301    
302    
303    
304                                                  ENDSEC

0    Errors
0    Warnings


